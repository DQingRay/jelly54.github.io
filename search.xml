<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode-07-反转整数]]></title>
    <url>%2F2018%2F10%2F21%2FLeetCode-07-%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定一个32位有符号整数，将整数中的数字进行反转。 示例1： 输入：123 输出：321 示例2： 输入：-123 输出：-321 示例3： 输入：120 输出：21 注意：假设我们的环境只能存储32位有符号整数，其数值范围是[-2^31 , 2^31 - 1]。根据这个假设，如果反转后的整数溢出，则返回0. 解决方案：方法：弹出和推入数字 &amp; 溢出前进行检查思路: 我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。 算法 反转整数的方法可以与反转字符串进行类比。我们想重复“弹出”x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。 要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。 1234567//pop operation:pop = x % 10;x /= 10;//push operation:temp = rev * 10 + pop;rev = temp; 但是，这种方法很危险，因为当 最后一高位进行push 操作时，可能会造成溢出。因此，要在最后一次push前进行范围检查。 1234567891011121314public static int reverse(int x) &#123; double r = 0; while (true) &#123; int f = x % 10; x /= 10; if(x==0)&#123; if (r*10+f &gt; Integer.MAX_VALUE || r*10+f &lt; Integer.MIN_VALUE) return 0; else return (int)r*10+f; &#125; r = r * 10 + f; &#125;&#125; 复杂度分析 时间复杂度：O(log(x))，x 中大约有 log10(x) 位数字。 空间复杂度：O(1)。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-26-删除数组中的重复项]]></title>
    <url>%2F2018%2F10%2F21%2FLeetCode-26-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意 输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 解决方案方法一： 双指针算法 数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。当我们遇到 nums[j] != nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它nums[j]的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 达数组的末尾为止。1234567891011public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; 复杂度分析 时间复杂度：15ms, O(n)， 假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。 空间复杂度：O(1)。 方法二：我的做法 双指针 一快一慢两个指针。`javapublic static intremoveDuplicates(it[] nums) { if(nums.length== 0) return 0; int i = 0, j =1; while(j &lt;=nums.length -1) { if(nums[i]== nums[j]){ j++; }elseif(nums[i] &lt;nums[j]){ swap(nums,++i, j++); } } return i+1;}private static voidswap(int[] nums,int i, int j) { int tmp =nums[i]; nums[i] =nums[j]; nums[j] = tmp; }` 复杂度分析 时间复杂度：9ms, O(n)， 假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。 空间复杂度：O(1)。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-06-Z字形变换]]></title>
    <url>%2F2018%2F10%2F21%2FLeetCode-06-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：123P A H N A P L S I I GY I R 之后从左往右，逐行读取字符 “PAHNAPLSIIGYIR”实现一个将字符串进行指定行数变换的函数： ++string convert(string s, int numRows);++ 示例1： 输入: s = “PAYPALISHIRING”, numRows = 3 输出: “PAHNAPLSIIGYIR” 示例 2: 输入: s = “PAYPALISHIRING”, numRows = 4 输出: “PINALSIGYAHRPI” 解释: 1234P I NA L S I GY A H RP I 解决方案方法一： 按行排序思路 通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。 算法 我们可以使用 min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。 从左到右迭代 s，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。 只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。 1234567891011121314151617181920212223class Solution &#123; public String convert(String s, int numRows) &#123; if (numRows == 1) return s; List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; Math.min(numRows, s.length()); i++) rows.add(new StringBuilder()); int curRow = 0; boolean goingDown = false; for (char c : s.toCharArray()) &#123; rows.get(curRow).append(c); if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown; curRow += goingDown ? 1 : -1; &#125; StringBuilder ret = new StringBuilder(); for (StringBuilder row : rows) ret.append(row); return ret.toString(); &#125;&#125; 复杂度分析 时间复杂度：O(n)，其中 n == len(s) 空间复杂度：O(n) 方法二：按行访问思路 按照与逐行读取 Z 字形图案相同的顺序访问字符串。 算法 首先访问 行 0 中的所有字符，接着访问 行 1，然后 行 2，依此类推… 对于所有整数 k， 行 0 中的字符位于索引 k(2⋅numRows−2) 处; 行 numRows − 1 中的字符位于索引 k(2⋅numRows − 2) + numRows − 1 处; 内部的 行 ii 中的字符位于索引 k(2⋅numRows − 2) + i 以及(k+1)(2⋅numRows − 2) − i 处; 12345678910111213141516171819202122232425262728class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows == 1 || s == null || s.length() &lt; numRows) return s; String res = ""; int n1 = 2*numRows - 2, n2 = 0; for (int i = 0; i &lt; numRows; i++) &#123; int j = i;//字符的下标 res += s.charAt(j); boolean st1 = true,st2 = true; while(st1 || st2)&#123; if(n1 &gt; 0 &amp;&amp; (j += n1)&lt; s.length())&#123; res += s.charAt(j); &#125;else&#123; st1 = false; &#125; if(n2 &gt; 0 &amp;&amp; (j += n2)&lt; s.length())&#123; res += s.charAt(j); &#125;else&#123; st2 = false; &#125; &#125; n1 -= 2; n2 += 2; &#125; return res; &#125;&#125; 复杂度分析 时间复杂度：O(n)，其中 n == len(s)。每个索引被访问一次。 空间复杂度：O(n)。对于 cpp 实现，如果返回字符串不被视为额外空间，则复杂度为 O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-05-最长回文子串]]></title>
    <url>%2F2018%2F10%2F21%2FLeetCode-05-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例 1： 输入: “babad” 输出: “bab” 注意: “aba”也是一个有效答案。 示例 2： 输入: “cbbd” 输出: “bb” 解决方案：方法一：动态规划 我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑“ababa” 这个示例。如果我们已经知道“bab”是回文，那么，“ababa”一定是回文，因为他的左首字母和右尾字母是相同的。 我们给出P(i, j) 的定义如下：P(i, j)={true, 如果子串Si, ….Sj是回文子串} {false， 其他情况} 因此， P(i , j) = (P(i + 1, j - 1) and Si == Sj) 基本示例例如下： P(i , j) = trueP(i , i+1) = (Si == Si+1) 这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并以此类推… 复杂度分析 时间复杂度：O(n^2)，这里给出我们的运行时间复杂度为O(n^2). 空间复杂度：O(n^2)，该方法使用O(n^2)的空间存储表。 方法二：中心扩展算法 事实上，只需使用恒定的时间，我们就可以在O(n^2)的时间内解决这个问题。 我们观察到回文中心的两侧互为镜像。因此，回文可以从他的中心展开，并且只有2n-1 个这样的中心. 你可能会问，为什么是2n-1个，而不是n个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间(例如“abba”的中心在两个b之间)。 12345678910111213141516171819202122class Solution &#123; private int index, len; public String longestPalindrome(String s) &#123; if(s.length() &lt; 2) return s; for(int i = 0; i &lt; s.length() - 1; i++)&#123; palindromHelp(s , i, i); palindromHelp(s , i, i+1); &#125; return s.substring(index, index + len); &#125; public void palindromHelp(String s, int l, int r)&#123; while(l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r))&#123; l--; r++; &#125; if(len&lt;r-l-1)&#123; index = l + 1; len = r - l - 1; &#125; &#125;&#125; 复杂度分析 时间复杂度：O(n^2)，由于围绕中心来扩展回文会好去O(n)的时间，所以总的复杂度为O(n^2) 空间复杂度：O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-04-两个排序数组的中位数]]></title>
    <url>%2F2018%2F10%2F21%2FLeetCode-04-%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定两个大小为 m 和 n 的有序数组 nums1 和 nums2请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。你可以假设 nums1 和 nums2 不同时为空。 示例 1: nums1 = [1, 3] nums2 = [2] 中位数是 2.0 示例 2: nums1 = [1, 2] nums2 = [3, 4] 中位数是 (2 + 3)/2 = 2.5 解决方案：方法一： 利用归并排序的merge、部分 因为给定的两个排好序的数组，很容易想到归并排序的merge阶段。将两个排好序的数组合并，恰好只需要 O(m+n) 复杂度。 1234567891011121314151617public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int[] help = new int[nums1.length +nums2.length]; int i = 0; int l1 = 0 , l2 = 0; while (l1 &lt;= nums1.length - 1 &amp;&amp; l2 &lt;=nums2.length - 1) &#123; help[i++] = nums1[l1] &lt; nums2[l2]? nums1[l1++] : nums2[l2++]; &#125; while (l1 &lt;= nums1.length - 1) &#123; help[i++] = nums1[l1++]; &#125; while (l2 &lt;= nums2.length - 1) &#123; help[i++] = nums2[l2++]; &#125; if(help.length % 2 == 0) return (help[help.length/2] +help[help.length/2 - 1] + 0.0)/2; return help[help.length/2];&#125; 复杂度分析: 时间复杂度：O(n)，将两个排序的数组合并O(m+n)，找到中位数只需要O(1)的时间 空间复杂度：o(m+n),需要一个m+n大小的辅助数组，具体要看给定的nums1和nums2的大小 方法二： 递归法 为了解决这个问题，我们需要理解“中位数的作用是什么”。在统计中，中位数被用来： 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。 如果理解了中位数的划分作用，我们就很接近答案了。首先，让我们在任一位置 i 将 A 分成两个部分： left_A | right_A A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] 由于 A 中有 m 个元素， 所以我们有 m+1 种划分的方法（i = 0 ∼ m）。 我们知道： 1len(left\_A) = i, len(right\_A) = m - i 注意：当 i=0 时，left_A 为空集， 而当 i = m时,right_A 为空集。 采用同样的方式，我们在任一位置 jj 将 \text{B}B 划分成两个部分： left_B | right_B B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 将 left_A 和 left_B 放入一个集合，并将right_A 和 right_B 放入另一个集合。再把这两个新的集合分别命名为 left_part 和 right_part： left_part | right_part A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 如果我们可以确认： 1231. len(left\_part) = len(right\_part)2. max(left\_part) = min(right\_part) 那么，我们已经将 {A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么：1median= \frac&#123;max(left\_part)+min(right\_part)&#125;&#123;2&#125; 要确保这两个条件，我们只需要保证： i + j = m - i + n - j（或：m - i + n - j + 1） 如果 n ≥ m，只需要使 i = 0 ~ m, 1j = \frac&#123;m + n + 1&#125;&#123;2&#125; - i B[j - 1] &lt;= A[i] 以及 A[i - 1] &lt; B[j] ps.1 为了简化分析，我假设 A[i-1], B[j-1], A[i], B[j] 总是存在，哪怕出现 i=0，i=m，j=0，或是 j=n 这样的临界条件。 我将在最后讨论如何处理这些临界值。 ps.2 为什么n ≥ m？由于0 ≤ i ≤ m 且12345678910j = \frac&#123;m + n + 1&#125;&#123;2&#125; - i``` 我必须确保 j 不是负数。如果 n &lt; m，那么 j 将可能是负数，而这会造成错误的答案。所以，我们需要做的是：在 [0，m] 中搜索并找到目标对象 i，以使：&gt; B[j−1] ≤ A[i] 且 A[i−1] ≤ B[j], 其中 ```mathj = \frac&#123;m + n + 1&#125;&#123;2&#125; 接着，我们可以按照以下步骤来进行二叉树搜索：详情看这里 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public double findMedianSortedArrays(int[] A, int[] B) &#123; int m = A.length; int n = B.length; if (m &gt; n) &#123; // to ensure m&lt;=n int[] temp = A; A = B; B = temp; int tmp = m; m = n; n = tmp; &#125; int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) &#123; int i = (iMin + iMax) / 2; int j = halfLen - i; if (i &lt; iMax &amp;&amp; B[j-1] &gt; A[i])&#123; iMin = i + 1; // i is too small &#125; else if (i &gt; iMin &amp;&amp; A[i-1] &gt; B[j]) &#123; iMax = i - 1; // i is too big &#125; else &#123; // i is perfect int maxLeft = 0; if (i == 0) &#123; maxLeft = B[j-1]; &#125; else if (j == 0) &#123; maxLeft = A[i-1]; &#125; else &#123; maxLeft = Math.max(A[i-1], B[j-1]); &#125; if ( (m + n) % 2 == 1 ) &#123; return maxLeft; &#125; int minRight = 0; if (i == m) &#123; minRight = B[j]; &#125; else if (j == n) &#123; minRight = A[i]; &#125; else &#123; minRight = Math.min(B[j], A[i]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0; &#125;&#125; 复杂度分析： 时间复杂度：O(log(min(m,n)))，首先，查找的区间是 [0, m]。而该区间的长度在每次循环之后都会减少为原来的一半。 所以，我们只需要执行 log(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为O(log(m))。由于，m ≤ n 所以时间复杂度是 O(log(min(m,n)))。 空间复杂度：O(1)，我们只需要恒定的内存来存储 9 个局部变量， 所以空间复杂度为 O(1)。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-03-无重复字符的最长子串]]></title>
    <url>%2F2018%2F10%2F20%2FLeetCode-03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[给定一个字符串，找出不含有重复字符的最长子串的长度。 示例 1: 输入: “abcabcbb” 输出: 3 解释: 无重复字符的最长子串是 “abc”，其长度为3。 示例 2: 输入: “bbbbb” 输出: 1 解释: 无重复字符的最长子串是 “b”，其长度为 1。 示例 3: 输入: “pwwkew” 输出: 3 解释: 无重复字符的最长子串是 “wke”，其长度为 3。 请注意: 答案必须是一个子串，”pwke” 是一个子序列 而不是子串。 解决方案：方法一：滑动窗口 如果从索引 i 到 j-1 之间的子字符串 s_{ij}已经被检查为没有重复字符。我们只需要检查s[j] 对应的字符是否已经存在于子字符串 s_{ij}中。 要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为 O(n^2)的算法，但我们可以做得更好。 通过使用 HashSet 作为 滑动窗口 ，我们可以用 O(1)的时间来完成对字符是否在当前的子字符串中的检查。滑动窗口 是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i,j)（左闭，右开） 。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。 例如，我们将[i,j)向右滑动1个元素，则它将变为 [i+1,j+1)（左闭，右开）。 回到我们的问题，我们使用HashSet将字符存储在当前窗口 [i, j)（最初 j = ij=i）中。然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。 此时，我们找到的没有重复字符的最长子字符串将会以索引 ii 开头。如果我们对所有的 ii 这样做，就可以得到答案。 123456789101112131415161718public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; // try to extend the range [i, j] if (!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125; 复杂度分析: 时间复杂度：O(2n)=O(n)，在最糟糕的情况下，每个字符将被 i 和 j 访问两次。 空间复杂度：O(min(m,n))，与之前的方法相同。滑动窗口法需要 O(k) 的空间，其中 k 表示 Set 的大小。而Set的大小取决于字符串n的大小以及字符集/字母 m 的大小。 方法二： 优化的滑动窗口 上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。 也就是说，如果 s[j] 在 [i,j) 范围内有与 j’ 重复的字符，我们不需要逐渐增加 i 。我们可以直接跳过 [i，j’]范围内的所有元素，并将 i 变为 j’ + 1。 Java（使用 HashMap） 1234567891011121314class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int l = 0; for (int j = 0, i = 0; j &lt; s.length(); j++) &#123; if(map.containsKey(s.charAt(j)))&#123; i = Math.max(map.get(s.charAt(j)), i);//两重复字符间最大 &#125; l = Math.max(j-i+1,l);//记录滑块最大的 map.put(s.charAt(j), j+1); &#125; return l; &#125;&#125; 方法三： 优化的滑动窗口2划重点Java（假设字符集为 ASCII 128） 以前的我们都没有对字符串 s 所使用的字符集进行假设。 当我们知道该字符集比较小的时侯，我们可以用一个整数数组作为直接访问表来替换 Map。 常用的表如下所示： int [26] 用于字母 ‘a’ - ‘z’或 ‘A’ - ‘Z’ int [128] 用于ASCII码 int [256] 用于扩展ASCII码 12345678910111213public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; &#125; return ans; &#125;&#125; 复杂度分析: 时间复杂度：O(n)，索引 j 将会迭代 n 次。 空间复杂度（HashMap）：O(min(m,n))，与之前的方法相同。 空间复杂度（Table）：O(m)，m是字符集的大小。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-02-两个链表相加]]></title>
    <url>%2F2018%2F10%2F20%2FLeetCode-02-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0之外，这两个数字都不会以零开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 解决方案：算法：就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。由于每位数字都应当处于0···9的范围内，我们计算两个数字的和时可能会出现“溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为 22，并将进位 carry = 1带入下一次迭代。进位 carry 必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19。 伪代码如下： 将当前结点初始化为返回列表的哑结点。 将进位 carrycarry 初始化为 00。 将 pp 和 qq 分别初始化为列表 l1l1 和 l2l2 的头部。 遍历列表 l1l1 和 l2l2 直至到达它们的尾端。 将 x 设为结点 pp 的值。如果 p 已经到达 l1 的末尾，则将其值设置为 0。 将 y 设为结点 q 的值。如果 q 已经到达 l2 的末尾，则将其值设置为 0。 设定 sum = x + y + carry。 更新进位的值，carry = sum / 10。 创建一个数值为 (sum mod 10)的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。 同时，将 p 和 q 前进到下一个结点。 检查 carry = 1 是否成立，如果成立，则向返回列表追加一个含有数字 1 的新结点。 返回哑结点的下一个结点。 请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。 测试用例 说明 l1 = [0, 1] l2 =[0, 1, 2] 当一个列表比另一个列表长时 l1 = []l2 = [0, 1] 当一个列表为空时，即出现空列表 l1 = [9, 9]l2 = [1] 求和运算最后可能出现额外的进位，这一点很容易被遗忘 12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode sumNode = new ListNode(0); ListNode p = l1, q = l2, cursumNode; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(su10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return sumNode.next;&#125; 复杂度分析: 时间复杂度：O(max(m, n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max(m, n) 次。 空间复杂度：O(\max(m, n))O(max(m,n))， 新列表的长度最多为 \max(m,n) + 1max(m,n)+1。 拓展 如果链表中的数字不是按逆序存储的呢？例如： (3 → 4 → 2) + (4 → 6 → 5) = 8 → 0 → 7]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-01_两数之和]]></title>
    <url>%2F2018%2F10%2F20%2FLeetCode-01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解决方案：方法一: 暴力法 暴力法很简单。遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素1234567891011121314151617181920212223242526272829303132333435363738public int[] twoSum(int[] nums, int target)&#123; if(nums == null || nums.length &lt; 2) return null; for(int i = 0; i &lt; nums.length - 1;i++)&#123; for(int j = i + 1; j &lt; nums.length;j++)&#123; if(nums[i] + nums[j] ==target)&#123; return new int[]&#123;i,j&#125;; &#125; &#125; &#125; return null;&#125;``` #### 复杂度分析：- 时间复杂度：O(n^2)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)。 - 空间复杂度：O(1)。 &lt;br/&gt;### 方法二：两遍哈希表&gt;在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素(target -nums[i])是否存在于表中。**注意**，该目标元素不能是 nums[i]本身！ ```javaclass Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length ; i ++)&#123; map.put(nums[i], i); &#125; for(int i = 0; i &lt; nums.length; i++)&#123; int compare = target - nums[i]; if(map.containsKey(compare) &amp;&amp; map.get(compare) != i)&#123; return new int[]&#123;i,map.get(compare)&#125;; &#125; &#125; throw new IllegalArgumentException("No two sum solution"); &#125;&#125; 复杂度分析： 时间复杂度：O(n)， 我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。 方法三：一遍哈希表 在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素对应的目标元素。如果存在，那我们已经找到了对迎接并立即将其返回。1234567891011public int[] twoSum(int[] nums, int target)&#123; Map&lt;Integer, Integer&gt; map = newHashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; int compare = target - nums[i]; if(map.containsKey(compare) &amp;&amp;map.get(compare) != i)&#123; return newint[]&#123;map.get(compare), i&#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("Notwo sum solution");&#125; 复杂度分析: 时间复杂度：O(n)，我们之遍历了包含有n个元素的列表一次次。在表中进行的每次查找只花费O(1)的时间。 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储n个元素。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左神算法-04_小和问题和逆序对问题]]></title>
    <url>%2F2018%2F10%2F18%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-04_%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98%26%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左神算法-03-master公式&归并排序]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-03_master%E5%85%AC%E5%BC%8F%26%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[剖析递归行为和递归行为时间复杂度的估算以及归并排序 剖析递归行为和递归行为时间复杂度的估算一个递归行为的例子 master公式的使用 T(N) = a*T(N/b) + O(N^d) T(N)是样本量为N时的时间复杂度，N/b是划分成子问题的样本量，子问题发生了a次，后面O(N^d)是除去调用子过程之外的时间复杂度。 比如要求一个数组的最大值：1234567891011public static int getMax(int[] arr, int L, int R) &#123; if (L == R) &#123; return arr[L]; &#125; int mid = (L + R) &gt;&gt;&gt; 1; int maxLeft = getMax(arr, L, mid); int maxRight = getMax(arr, mid + 1, R); return Math.max(maxLeft, maxRight);&#125;//master公式： T(N) = 2*T(N/2) + O(1); 这里划分成的递归子过程的样本量是N/2，这个相同的样本量发生了2次，除去调用子过程之外的时间复杂度是O(1),因为求最大值和判断if复杂度是O(1),所以N^d=1，所以d=0. 那么根据如下公式判断 log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a)) log(b,a) = d -&gt; 复杂度为O(N^d * logN) log(b,a) &lt; d -&gt; 复杂度为O(N^d) 这里log(b, a)(以b为底a的对数) = log(2, 2)=1 &gt; d=0所以复杂度为O(N^log(2, 2))===&gt;O(N)，因此也就可以解释为什么归并排序的时间复杂度为nlogn了 归并排序 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。 12345678910111213141516171819202122232425262728293031323334public static void mergeSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; mergeSort(arr, 0, arr.length - 1);&#125;public static void mergeSort(int[] arr, int l, int r) &#123; if (l == r) &#123; return; &#125; int mid = l + ((r - l) &gt;&gt; 1); mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); merge(arr, l, mid, r);&#125;public static void merge(int[] arr, int l, int m, int r) &#123; int[] help = new int[r - l + 1]; int i = 0; int p1 = l; int p2 = m + 1; while (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123; help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] :arr[p2++]; &#125; while (p1 &lt;= m) &#123; help[i++] = arr[p1++]; &#125; while (p2 &lt;= r) &#123; help[i++] = arr[p2++]; &#125; for (i = 0; i &lt; help.length; i++) &#123; arr[l + i] = help[i]; &#125;&#125; 总结： 归并排序是稳定排序，他也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左神算法-02_简单排序]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-02_%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。我们这里说说八大排序的内部排序。 概述 排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。我们这里说说八大排序的内部排序。 当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短； 冒泡排序 冒泡排序的核心是从头遍历序列。以升序排列为例：将第一个元素和第二个元素比较，若前者大于后者，则交换两者的位置，再将第二个元素与第三个元素比较，若前者大于后者则交换两者位置，以此类推直到倒数第二个元素与最后一个元素比较，若前者大于后者，则交换两者位置。这样一轮比较下来将会把序列中最大的元素移至序列末尾，这样就安排好了最大数的位置(每次找到一个最大的)，接下来只需对剩下的（n-1）个元素，重复上述操作即可. 123456789101112131415161718//时间复杂度O(N^2)， 额外空间复杂度O(1)public class Coding_00_bubbleSort &#123; public static void bubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = arr.length - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) swap(arr, j, j + 1); &#125; &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125;&#125; 插入排序 插入即表示将一个新的数据插入到一个有序数组中，并继续保持有序。例如有一个长度为N的无序数组，进行N-1次的插入即能完成排序；第一次，数组第1个数认为是有序的数组，将数组第二个元素插入仅有1个有序的数组中；第二次，数组前两个元素组成有序的数组，将数组第三个元素插入由两个元素构成的有序数组中……第N-1次，数组前N-1个元素组成有序的数组，将数组的第N个元素插入由N-1个元素构成的有序数组中，则完成了整个插入排序。 类似手里有一把排好序的牌，心哪一张和最后一个比较，看能插到前边哪个位置上。 12345678910111213141516171819//时间复杂度O(N^2)， 额外空间复杂度O(1)//实际时间和数据有关系O(N)~O(N^2)// 排好序的数据~逆序数据public class Coding_01_insertSort &#123; public static void insertSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123; swap(arr, j, j + 1); &#125; &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125;&#125; 选择排序 选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 注意: 选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置12345678910111213141516171819//时间复杂度O(N^2)， 额外空间复杂度O(1)public class Coding_02_selectSort &#123; public static void selectSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; for(int j = i + 1; j &lt; arr.length; j++)&#123; minIndex = arr[j] &lt; arr[minIndex] ? j: minIndex; &#125; swap(arr, i, minIndex); &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左神算法-01_时间复杂度]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-01_%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关。 时间复杂度 时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为O(n)），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于常数时间内的操作（对应时间复杂度O(1)）。 常数时间操作： 一个操作如果和数据量没有关系，每次都子啊固定时间内完成的操作，叫做常数操作。 在化简某算法时间复杂度表达式时需遵循以下规则： 对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如O(n^2)+O(n)可化简为O(n^2)，O(n)+O(1)可化简为O(n) 可省去样本量前的常量系数，如O(2n)可化简为O(n)，O(8)可化简为O(1) 对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如O(logm)+O(n^2)不能化简为O(n^2)或O(logm)。而要视m、n两者之间的差距来化简，比如m&gt;&gt;n时可以化简为O(logm)，因为表达式增量是由样本量决定的。 举个例子例1. 对一个长度为N的数组进行排序： 算法：依次从0—-N-1个数中选出最小的数，放在数组的0位置从1—N-2个数中选出最小的数，放在数组的1位置从2—N-3个数中选出最小的数，放在数组的2位置time=N+(N-1)+(N-2)*+1=(N+1)N/2只要高阶项，不要低阶项，也不要高阶项的系数所以时间复杂度位O（NN） 例2. 一个有序数组A，另一个无序数组B，请打印B中所有不在A中的数，A数组的长度为N，B数组的长度为M。 算法1：对于数组B中的每一个数，都在A中通过遍历的方式找一下； 算法2：对于数组B中的每一个数，都在A中通过二分的方式查找一下； 算法3：先把B中的数进行排序，然后用类似外排的方式打印所有不在A中出现的数。计算时间复杂度： 1、O(M*N)2、 ①对有序的数组，二分查找的时间复杂度O（logN） 底数为2 在1,3,5,6,8,10中找出x L………………R mid=(L+R)/2 ，根据,数组[mid]与x比较大小的结果，确定下一次二分的方向，N个数二分最多能分logN次。 ②所以算法2的时间复杂度为 O（MlogN）3、 ①对无序数组使用基于比较的排序算法O(MlogM) ②1,3,5,7,10,16,18;2,4,8,17,20 ….a…………………….b……]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F15%2F%E4%BD%A0%E5%A5%BD%E9%99%8C%E7%94%9F%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[你好, 陌生人 柳絮抚风，微醺了浅湖 我轻触你指尖的纹路 诧异流连眼眸 抵不过掌心的温柔 你不问我来方 我不知你去向 只默然凝望 欢迎来到 Jelly 的 blog，希望我的文章对你的学习有帮助。blog中如有不妥之处，欢迎随时留言指正。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
