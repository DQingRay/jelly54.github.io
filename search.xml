<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[左神算法-03-master公式&快排]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-03-master%E5%85%AC%E5%BC%8F%26%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左神算法-03-master公式&归并排序]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-03-master%E5%85%AC%E5%BC%8F-%E5%BF%AB%E6%8E%92%2F</url>
    <content type="text"><![CDATA[##剖析递归行为和递归行为时间复杂度的估算一个递归行为的例子 master公式的使用 T(N) = a*T(N/b) + O(N^d) T(N)是样本量为N时的时间复杂度，N/b是划分成子问题的样本量，子问题发生了a次，后面O(N^d)是除去调用子过程之外的时间复杂度。 比如要求一个数组的最大值：1234567891011public static int getMax(int[] arr, int L, int R) &#123; if (L == R) &#123; return arr[L]; &#125; int mid = (L + R) &gt;&gt;&gt; 1; int maxLeft = getMax(arr, L, mid); int maxRight = getMax(arr, mid + 1, R); return Math.max(maxLeft, maxRight);&#125;//master公式： T(N) = 2*T(N/2) + O(1); &amp;nbsp&amp;nbsp这里划分成的递归子过程的样本量是N/2，这个相同的样本量发生了2次，除去调用子过程之外的时间复杂度是O(1),因为求最大值和判断if复杂度是O(1),所以N^d=1，所以d=0. 那么根据如下公式判断 log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a)) log(b,a) = d -&gt; 复杂度为O(N^d * logN) log(b,a) &lt; d -&gt; 复杂度为O(N^d) 这里log(b, a)(以b为底a的对数) = log(2, 2)=1 &gt; d=0 所以复杂度为O(N^log(2, 2))===&gt;O(N)，因此也就可以解释为什么归并排序的时间复杂度为nlogn了 归并排序 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。12345678910111213141516171819202122232425262728293031323334public static void mergeSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; mergeSort(arr, 0, arr.length - 1);&#125;public static void mergeSort(int[] arr, int l, int r) &#123; if (l == r) &#123; return; &#125; int mid = l + ((r - l) &gt;&gt; 1); mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); merge(arr, l, mid, r);&#125;public static void merge(int[] arr, int l, int m, int r) &#123; int[] help = new int[r - l + 1]; int i = 0; int p1 = l; int p2 = m + 1; while (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123; help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] :arr[p2++]; &#125; while (p1 &lt;= m) &#123; help[i++] = arr[p1++]; &#125; while (p2 &lt;= r) &#123; help[i++] = arr[p2++]; &#125; for (i = 0; i &lt; help.length; i++) &#123; arr[l + i] = help[i]; &#125;&#125; ###总结：归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左神算法-02_简单排序]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-02-%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[##概述排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。我们这里说说八大排序就是内部排序。 当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短； ###冒泡排序&gt;冒泡排序的核心是从头遍历序列。以升序排列为例：将第一个元素和第二个元素比较，若前者大于后者，则交换两者的位置，再将第二个元素与第三个元素比较，若前者大于后者则交换两者位置，以此类推直到倒数第二个元素与最后一个元素比较，若前者大于后者，则交换两者位置。这样一轮比较下来将会把序列中最大的元素移至序列末尾，这样就安排好了最大数的位置(每次找到一个最大的)，接下来只需对剩下的（n-1）个元素，重复上述操作即可. //时间复杂度O(N^2)， 额外空间复杂度O(1) public class Coding_00_bubbleSort { public static void bubbleSort(int[] arr) { if (arr == null || arr.length &lt; 2) return; for (int i = arr.length - 1; i &gt; 0; i--) { for (int j = 0; j &lt; i; j++) { if (arr[j] &gt; arr[j + 1]) swap(arr, j, j + 1); } } } private static void swap(int[] arr, int i, int j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; } } ###插入排序 插入即表示将一个新的数据插入到一个有序数组中，并继续保持有序。例如有一个长度为N的无序数组，进行N-1次的插入即能完成排序；第一次，数组第1个数认为是有序的数组，将数组第二个元素插入仅有1个有序的数组中；第二次，数组前两个元素组成有序的数组，将数组第三个元素插入由两个元素构成的有序数组中……第N-1次，数组前N-1个元素组成有序的数组，将数组的第N个元素插入由N-1个元素构成的有序数组中，则完成了整个插入排序。 类似手里有一把排好序的牌，心哪一张和最后一个比较，看能插到前边哪个位置上。 //时间复杂度O(N^2)， 额外空间复杂度O(1) //实际时间和数据有关系O(N)~O(N^2) // 排好序的数据~逆序数据 public class Coding_01_insertSort { public static void insertSort(int[] arr) { if (arr == null || arr.length &lt; 2) return; for (int i = 1; i &lt; arr.length; i++) { for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) { swap(arr, j, j + 1); } } } private static void swap(int[] arr, int i, int j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; } } ###选择排序 选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 注意: 选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置 //时间复杂度O(N^2)， 额外空间复杂度O(1) public class Coding_02_selectSort { public static void selectSort(int[] arr) { if (arr == null || arr.length &lt; 2) return; for (int i = 0; i &lt; arr.length - 1; i++) { int minIndex = i; for(int j = i + 1; j &lt; arr.length; j++){ minIndex = arr[j] &lt; arr[minIndex] ? j: minIndex; } swap(arr, i, minIndex); } } private static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } }]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法,排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左神算法-01_时间复杂度]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-01_%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[时间复杂度 时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为O(n)），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于常数时间内的操作（对应时间复杂度O(1)）。 &lt;br//&gt; 常数时间操作： 一个操作如果和数据量没有关系，每次都子啊固定时间内完成的操作，叫做常数操作。 在化简某算法时间复杂度表达式时需遵循以下规则： 对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如O(n^2)+O(n)可化简为O(n^2)，O(n)+O(1)可化简为O(n) 可省去样本量前的常量系数，如O(2n)可化简为O(n)，O(8)可化简为O(1) 对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如O(logm)+O(n^2)不能化简为O(n^2)或O(logm)。而要视m、n两者之间的差距来化简，比如m&gt;&gt;n时可以化简为O(logm)，因为表达式增量是由样本量决定的。 举个例子例1. 对一个长度为N的数组进行排序： 算法：依次从0—-N-1个数中选出最小的数，放在数组的0位置从1—N-2个数中选出最小的数，放在数组的1位置从2—N-3个数中选出最小的数，放在数组的2位置time=N+(N-1)+(N-2)*+1=(N+1)N/2只要高阶项，不要低阶项，也不要高阶项的系数所以时间复杂度位O（NN） 例2. 一个有序数组A，另一个无序数组B，请打印B中所有不在A中的数，A数组的长度为N，B数组的长度为M。 算法1：对于数组B中的每一个数，都在A中通过遍历的方式找一下； 算法2：对于数组B中的每一个数，都在A中通过二分的方式查找一下； 算法3：先把B中的数进行排序，然后用类似外排的方式打印所有不在A中出现的数。计算时间复杂度： 1、O(M*N)2、 ①对有序的数组，二分查找的时间复杂度O（logN） 底数为2 在1,3,5,6,8,10中找出x L………………R mid=(L+R)/2 ，根据,数组[mid]与x比较大小的结果，确定下一次二分的方向，N个数二分最多能分logN次。 ②所以算法2的时间复杂度为 O（MlogN）3、 ①对无序数组使用基于比较的排序算法O(MlogM) ②1,3,5,7,10,16,18;2,4,8,17,20….a…………………….b……]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
