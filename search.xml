<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[左神算法-02_简单排序]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-02-%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[左神算法_02-简单排序算法标签（空格分隔）： 算法 排序 ###概述排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。我们这里说说八大排序就是内部排序。 当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短； ###冒泡排序 冒泡排序的核心是从头遍历序列。以升序排列为例：将第一个元素和第二个元素比较，若前者大于后者，则交换两者的位置，再将第二个元素与第三个元素比较，若前者大于后者则交换两者位置，以此类推直到倒数第二个元素与最后一个元素比较，若前者大于后者，则交换两者位置。这样一轮比较下来将会把序列中最大的元素移至序列末尾，这样就安排好了最大数的位置(每次找到一个最大的)，接下来只需对剩下的（n-1）个元素，重复上述操作即可. 123456789101112131415161718//时间复杂度O(N^2)， 额外空间复杂度O(1)public class Coding_00_bubbleSort &#123; public static void bubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = arr.length - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) swap(arr, j, j + 1); &#125; &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125;&#125; ###插入排序 插入即表示将一个新的数据插入到一个有序数组中，并继续保持有序。例如有一个长度为N的无序数组，进行N-1次的插入即能完成排序；第一次，数组第1个数认为是有序的数组，将数组第二个元素插入仅有1个有序的数组中；第二次，数组前两个元素组成有序的数组，将数组第三个元素插入由两个元素构成的有序数组中……第N-1次，数组前N-1个元素组成有序的数组，将数组的第N个元素插入由N-1个元素构成的有序数组中，则完成了整个插入排序。 类似手里有一把排好序的牌，心哪一张和最后一个比较，看能插到前边哪个位置上。12345678910111213141516171819//时间复杂度O(N^2)， 额外空间复杂度O(1)//实际时间和数据有关系O(N)~O(N^2)// 排好序的数据~逆序数据public class Coding_01_insertSort &#123; public static void insertSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123; swap(arr, j, j + 1); &#125; &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125;&#125; ###选择排序 选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 注意: 选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置12345678910111213141516171819//时间复杂度O(N^2)， 额外空间复杂度O(1)public class Coding_02_selectSort &#123; public static void selectSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; for(int j = i + 1; j &lt; arr.length; j++)&#123; minIndex = arr[j] &lt; arr[minIndex] ? j: minIndex; &#125; swap(arr, i, minIndex); &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法,排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左神算法_01_时间复杂度]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-01_%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[左神算法_01-时间复杂度 时间复杂度 时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为O(n)），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于常数时间内的操作（对应时间复杂度O(1)）。 常数时间操作： 一个操作如果和数据量没有关系，每次都子啊固定时间内完成的操作，叫做常数操作。 在化简某算法时间复杂度表达式时需遵循以下规则： 对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如O(n^2)+O(n)可化简为O(n^2)，O(n)+O(1)可化简为O(n) 可省去样本量前的常量系数，如O(2n)可化简为O(n)，O(8)可化简为O(1) 对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如O(logm)+O(n^2)不能化简为O(n^2)或O(logm)。而要视m、n两者之间的差距来化简，比如m&gt;&gt;n时可以化简为O(logm)，因为表达式增量是由样本量决定的。 举个例子例1. 对一个长度为N的数组进行排序： 算法：依次从0—-N-1个数中选出最小的数，放在数组的0位置从1—N-2个数中选出最小的数，放在数组的1位置从2—N-3个数中选出最小的数，放在数组的2位置time=N+(N-1)+(N-2)*+1=(N+1)N/2只要高阶项，不要低阶项，也不要高阶项的系数所以时间复杂度位O（NN） 例2. 一个有序数组A，另一个无序数组B，请打印B中所有不在A中的数，A数组的长度为N，B数组的长度为M。 算法1：对于数组B中的每一个数，都在A中通过遍历的方式找一下； 算法2：对于数组B中的每一个数，都在A中通过二分的方式查找一下； 算法3：先把B中的数进行排序，然后用类似外排的方式打印所有不在A中出现的数。计算时间复杂度： 1、O(M*N)2、 ①对有序的数组，二分查找的时间复杂度O（logN） 底数为2 在1,3,5,6,8,10中找出x L………………R mid=(L+R)/2 ，根据,数组[mid]与x比较大小的结果，确定下一次二分的方向，N个数二分最多能分logN次。 ②所以算法2的时间复杂度为 O（MlogN）3、 ①对无序数组使用基于比较的排序算法O(MlogM) ②1,3,5,7,10,16,18;2,4,8,17,20….a…………………….b……]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
