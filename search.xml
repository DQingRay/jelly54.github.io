<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode-392-判断子序列]]></title>
    <url>%2F2018%2F11%2F19%2FLeetCode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[判断子序列LeetCode-392-判断子序列 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1: s = “abc”, t = “ahbgdc” 返回 true. 示例 2: s = “axc”, t = “ahbgdc” 返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿,你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 解决方案方法一：123456789101112class Solution &#123; public boolean isSubsequence(String s, String t) &#123; int index = -1; for (char c : s.toCharArray()) &#123; index = t.indexOf(c, index + 1); if (index == -1) &#123; return false; &#125; &#125; return true; &#125;&#125; 复杂度分析 时间复杂度: O(N) 空间复杂度：O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-605-种花问题]]></title>
    <url>%2F2018%2F11%2F19%2FLeetCode-605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[种花问题LeetCode-605-种花问题 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 示例 1: 输入: flowerbed = [1,0,0,0,1], n = 1 输出: True 示例 2: 输入: flowerbed = [1,0,0,0,1], n = 2 输出: False 注意: 数组内已种好的花不会违反种植规则。 输入的数组长度范围为 [1, 20000]。 n 是非负整数，且不会超过输入数组的大小。 解决方案方法一： 花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。 12345678910111213141516public boolean canPlaceFlowers(int[] flowerbed, int n) &#123; int len = flowerbed.length; int cnt = 0; for (int i = 0; i &lt; len &amp;&amp; cnt &lt; n; i++) &#123; if (flowerbed[i] == 1) &#123; continue; &#125; int pre = i == 0 ? 0 : flowerbed[i - 1]; int next = i == len - 1 ? 0 : flowerbed[i + 1]; if (pre == 0 &amp;&amp; next == 0) &#123; cnt++; flowerbed[i] = 1; &#125; &#125; return cnt &gt;= n;&#125; 复杂度分析 时间复杂度：O() 空间复杂度：O()]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-406-根据身高重建队列]]></title>
    <url>%2F2018%2F11%2F19%2FLeetCode-406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[根据身高重建队列LeetCode-406-根据身高重建队列 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意：总人数少于1100人。 示例 输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解决方案方法一： 一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。 为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。 身高降序、k 值升序， 然后按排好序的顺序插入队列的第 k 个位置中 1234567891011public int[][] reconstructQueue(int[][] people) &#123; if (people == null || people.length == 0 || people[0].length == 0) &#123; return new int[0][0]; &#125; Arrays.sort(people, (a, b) -&gt; (a[0] == b[0] ? a[1] - b[1] : b[0] - a[0])); List&lt;int[]&gt; queue = new ArrayList&lt;&gt;(); for (int[] p : people) &#123; queue.add(p[1], p); &#125; return queue.toArray(new int[queue.size()][]);&#125; 复杂度分析 时间复杂度：O(N*logN) 空间复杂度：O(N)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-435-无重叠区间]]></title>
    <url>%2F2018%2F11%2F19%2FLeetCode-435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[不重叠区间LeetCode-435-无重叠区间 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 解决方案方法一： 先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。 在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。 按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。 123456789101112131415161718192021222324252627/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */class Solution &#123; public int eraseOverlapIntervals(Interval[] intervals) &#123; if(intervals.length == 0) return 0; Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o.end)); int cnt = 1; int end = intervals[0].end; for(int i=1;i&lt;intervals.length; i++)&#123; if(intervals[i].start &lt; end)&#123; continue; &#125; end = intervals[i].end; cnt++; &#125; return intervals.length - cnt; &#125;&#125; 使用 lambda 表示式创建 Comparator 会导致算法运行时间过长，如果注重运行时间，可以修改为普通创建 Comparator 语句：123456Arrays.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return o1.end - o2.end; &#125;&#125;); 复杂度分析 时间复杂度： O(N*logN) 空间复杂度： O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心思想</tag>
        <tag>不重叠区间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-452-用最少数量的箭引爆气球]]></title>
    <url>%2F2018%2F11%2F13%2FLeetCode-452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83%2F</url>
    <content type="text"><![CDATA[用最少数量的箭引爆气球LeetCode-cn-452-用最少数量的箭引爆气球 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。 一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 Example: 输入: [[10,16], [2,8], [1,6], [7,12]] 输出: 2 解释:对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。 解决方案方法一： 题目描述： 计算让一组区间不重叠所需要移除的区间个数。 先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。 在每次选择中，区间的结尾最为重要 选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。 按区间的结尾进行排序 ，每次选择 结尾最小，并且和前一个区间不重叠的区间 class Solution { public int findMinArrowShots(int[][] points) { if (points.length == 0) { return 0; } Arrays.sort(points,new Comparator&lt;int[]&gt;() { @Override public int compare(int[] p1, int[] p2) { return p1[1] - p2[1]; } }); int cnt = 1, end = points[0][1]; for (int i = 1; i &lt; points.length; i++) { if (points[i][0] &lt;= end) { continue; } cnt++; end = points[i][1]; } return cnt; } } 复杂度分析 时间复杂度： O(N*logN) 空间复杂度： O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心思想</tag>
        <tag>不重叠区间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-455-分发饼干]]></title>
    <url>%2F2018%2F11%2F13%2FLeetCode-455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%2F</url>
    <content type="text"><![CDATA[分发饼干LeetCode-cn-455-分发饼干 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意： 你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 示例 1: 输入: [1,2,3], [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 输入: [1,2], [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 解决方案方法一：贪心思想 题目描述： 每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。 给一个孩子的饼干 应当尽量小又能满足该孩子 ，这样大饼干就能拿来给满足度比较大的孩子。 因为最小的孩子最容易得到满足 ，所以先满足最小的孩子。 证明： 假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。 假设 存在一种最优策略，给该孩子分配第 n 个饼干，并且 m &lt; n。 我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。 因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。 1234567891011121314class Solution &#123; public int findContentChildren(int[] g, int[] s) &#123; Arrays.sort(g); Arrays.sort(s); int gi = 0, si = 0; while(gi &lt; g.length &amp;&amp; si &lt; s.length)&#123; if(g[gi] &lt;= s[si])&#123; gi++; &#125; si++; &#125; return gi; &#125;&#125; 复杂度分析 时间复杂度： O(N*logN) 空间复杂度： O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-75-颜色分类]]></title>
    <url>%2F2018%2F11%2F13%2FLeetCode-075-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[颜色分类LeetCode-cn-75-颜色分类 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？ 解决方案方法一：partition 看完题目，发现与荷兰国旗的分组的问题类似，将数组中的数据按照0,1,2 分成三组，大于1 的放右边；小于1 的放在左边；等于1 的放在中间。因此，可以确定如何实现。 PS: 如果 允许直接调用系统排序的方法 ，那么只需要一句话即可：Arrays.sort(nums); 123456789101112131415161718class Solution &#123; public void sortColors(int[] nums) &#123; int less = -1, more = nums.length, cur = 0; while(cur &lt; more)&#123; if(nums[cur] == 0) swap(nums, ++less, cur++); else if(nums[cur] == 2) swap(nums, --more, cur); else cur++; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int t = nums[i]; nums[i] = nums[j]; nums[j] = t; &#125;&#125; 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-451-根据字符出现频率排序]]></title>
    <url>%2F2018%2F11%2F11%2FLeetCode-451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[根据字符出现频率排序LeetCode-cn-451-根据字符出现频率排序 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例 1: 输入: “tree” 输出: “eert” 解释: ‘e’出现两次，’r’和’t’都只出现一次。因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。 示例 2: 输入: “cccaaa” 输出: “cccaaa” 解释: ‘c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。 注意 “cacaca”是不正确的，因为相同的字母必须放在一起。 示例 3: 输入: “Aabb” 输出: “bbAa” 解释: 此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。 注意 ‘A’和’a’被认为是两种不同的字符。 解决方案方法一：桶排序1234567891011121314151617181920212223242526public String frequencySort(String s) &#123; Map&lt;Character, Integer&gt; frequencyForNum = new HashMap&lt;&gt;(); for (char c : s.toCharArray()) frequencyForNum.put(c, frequencyForNum.getOrDefault(c, 0) + 1); List&lt;Character&gt;[] frequencyBucket = new ArrayList[s.length() + 1]; for (char c : frequencyForNum.keySet()) &#123; int f = frequencyForNum.get(c); if (frequencyBucket[f] == null) &#123; frequencyBucket[f] = new ArrayList&lt;&gt;(); &#125; frequencyBucket[f].add(c); &#125; StringBuilder str = new StringBuilder(); for (int i = frequencyBucket.length - 1; i &gt;= 0; i--) &#123; if (frequencyBucket[i] == null) &#123; continue; &#125; for (char c : frequencyBucket[i]) &#123; for (int j = 0; j &lt; i; j++) &#123; str.append(c); &#125; &#125; &#125; return str.toString();&#125; 复杂度分析 时间复杂度：O() 空间复杂度：O()]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>桶排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-347-前K个高频元素]]></title>
    <url>%2F2018%2F11%2F11%2FLeetCode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[前K个高频元素LeetCode-cn-347-前K个高频元素 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 数组的大小。 解决方案方法一：桶排序 设置若干个桶，每个桶存储出现频率相同的数，并且桶的下标代表桶中数出现的频率，即第 i 个桶中存储的数出现的频率为 i。 把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。 123456789101112131415161718192021public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; frequencyForNum = new HashMap&lt;&gt;(); for (int num : nums) &#123; frequencyForNum.put(num, frequencyForNum.getOrDefault(num, 0) + 1); &#125; List&lt;Integer&gt;[] buckets = new ArrayList[nums.length + 1]; for (int key : frequencyForNum.keySet()) &#123; int frequency = frequencyForNum.get(key); if (buckets[frequency] == null) &#123; buckets[frequency] = new ArrayList&lt;&gt;(); &#125; buckets[frequency].add(key); &#125; List&lt;Integer&gt; topK = new ArrayList&lt;&gt;(); for (int i = buckets.length - 1; i &gt;= 0 &amp;&amp; topK.size() &lt; k; i--) &#123; if (buckets[i] != null) &#123; topK.addAll(buckets[i]); &#125; &#125; return topK;&#125; 复杂度分析 时间复杂度：O(1) 空间复杂度：O(n), n为数组的大小]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>桶排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-215-数组中的第K大的元素]]></title>
    <url>%2F2018%2F11%2F09%2FLeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[数组中的第K大的元素LeetCode-cn-215-数组中的第K大的元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解决方案 给定的数组是无序的，要想拿到第K个大的数据，先要将数组排序，在获取数组的 nums。length - k 位置的数据即可。 方法一：利用数组自带的排序1234public int findKthLargest(int[] nums, int k) &#123; Arrays.sort(nums); return nums[nums.length - k];&#125; 复杂度分析 时间复杂度 O(NlogN) 空间复杂度 O(1) 方法二：堆排序 维持一个最大堆，name堆顶的元素将是最大的。将数据存入堆中，控制堆的大小为k，最后peek()一下就是第k大的数据。 123456789public int findKthLargest(int[] nums, int k) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); // 小顶堆 for (int val : nums) &#123; pq.add(val); if (pq.size() &gt; k) // 维护堆的大小为 K pq.poll(); &#125; return pq.peek();&#125; 复杂度分析 时间复杂度 O(NlogK) 空间复杂度 O(K)。 方法三： 快速选择1234567891011121314151617181920212223242526272829303132333435public int findKthLargest(int[] nums, int k) &#123; k = nums.length - k; int l = 0, h = nums.length - 1; while (l &lt; h) &#123; int j = partition(nums, l, h); if (j == k) &#123; break; &#125; else if (j &lt; k) &#123; l = j + 1; &#125; else &#123; h = j - 1; &#125; &#125; return nums[k];&#125;private int partition(int[] a, int l, int h) &#123; int i = l, j = h + 1; while (true) &#123; while (a[++i] &lt; a[l] &amp;&amp; i &lt; h) ; while (a[--j] &gt; a[l] &amp;&amp; j &gt; l) ; if (i &gt;= j) &#123; break; &#125; swap(a, i, j); &#125; swap(a, l, j); return j;&#125;private void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t;&#125; 复杂度分析 时间复杂度 O(N) 空间复杂度 O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>堆排序</tag>
        <tag>快速选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-633-平方数之和]]></title>
    <url>%2F2018%2F11%2F09%2FLeetCode-633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[平方数之和LeetCode-cn-633-平方数之和 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c。 示例1: 输入: 5 输出: True 解释: 1 1 + 2 2 = 5 示例2: 输入: 3 输出: False 解决方案方法一： 两个指针 一个数如果可以是另外两个数的平方和，那么这两个数必定都比这个书的开方后的值小。 因此，我们可以定义两个变量，一个从 0 开始，一个从Math.sqrt(c)) 开始。 将两数平方和 与 该数进行比较，若大于该数，则后指针减一;若小于该数，前指针加一。直到找见 与该数相等，返回 12345678910111213141516class Solution &#123; public boolean judgeSquareSum(int c) &#123; int i = 0, j = (int)Math.sqrt(c); while(i &lt;= j)&#123; int sum = i*i + j*j; if(sum == c)&#123; return true; &#125;else if(sum &gt; c)&#123; j--; &#125;else&#123; i++; &#125; &#125; return false; &#125;&#125; 复杂度分析 时间复杂度：O(N) 空间复杂度：O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-688-验证回文字符串2]]></title>
    <url>%2F2018%2F11%2F08%2FLeetCode-680-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[验证回文字符串2LeetCode-cn-688-验证回文字符串2 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: “aba” 输出: True 示例 2: 输入: “abca” 输出: True 解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 解决方案方法一：双指针 从string的，头和尾进行比较。如果两两相等。返回true；否则，如果遇见不相等的，则，前指针加一后指针不变，或者，后指针减一，前指针不变，继续判断是不是回文，如果两个有一个后边全是回文，则该string可以 经过删除零个或一个字符，构成回文。 1234567891011121314151617181920class Solution &#123; public boolean validPalindrome(String s) &#123; int i = -1, j = s.length(); while(++i &lt; --j)&#123; if(s.charAt(i) != s.charAt(j))&#123; return isPalindrom(s, i, j - 1) || isPalindrom(s, i+1, j); &#125; &#125; return true; &#125; private boolean isPalindrom(String s, int i, int j)&#123; while(i &lt; j)&#123; if(s.charAt(i++) != s.charAt(j--))&#123; return false; &#125; &#125; return true; &#125;&#125; 复杂度分析 时间复杂度：O(N) 空间复杂度：O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-141-判断链表是否有环]]></title>
    <url>%2F2018%2F11%2F08%2FLeetCode-141-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[判断环形链表LeetCode-cn-141-判断链表是否有环 给定一个链表，判断链表中是否有环。 进阶：你能否不使用额外空间解决此题？ 解决方案方法一：双指针 使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head == null) return false; ListNode l1 = head, l2 = head.next; while(l1 != null &amp;&amp;l2 != null &amp;&amp; l2.next != null)&#123; if(l1 == l2) return true; l1 = l1.next; l2 = l2.next.next; &#125; return false; &#125;&#125; 复杂度分析 时间复杂度：O(N) 空间复杂度：O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-345-反转字符串中的元音字母]]></title>
    <url>%2F2018%2F11%2F08%2FLeetCode-345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%2F</url>
    <content type="text"><![CDATA[反转字符串中的元音字母LeetCode-cn-345-反转字符串中的元音字母 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: “hello” 输出: “holle” 示例 2: 输入: “leetcode” 输出: “leotcede” 说明: 元音字母不包含字母”y”。 解决方案方法一 双指针 使用双指针指向待反转的两个元音字符，一个指针从头向尾遍历，一个指针从尾到头遍历。 123456789101112131415161718192021class Solution &#123; private final static HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')); public String reverseVowels(String s) &#123; int i = 0, j = s.length() - 1; char[] result = new char[s.length()]; while (i &lt;= j) &#123; char ci = s.charAt(i); char cj = s.charAt(j); if (!vowels.contains(ci)) &#123; result[i++] = ci; &#125; else if (!vowels.contains(cj)) &#123; result[j--] = cj; &#125; else &#123; result[i++] = cj; result[j--] = ci; &#125; &#125; return new String(result); &#125;&#125; 复杂度分析 时间复杂度：O(N) 空间复杂度：O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-167-两数之和2-输入有序数组]]></title>
    <url>%2F2018%2F10%2F22%2FLeetCode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[两数之和2-输入有序数组LeetCode-cn-167-两数之和2-输入有序数组 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 解决方案方法一：双指针 使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。 如果两个指针指向元素的和 sum == target，那么得到要求的结果； 如果 sum &gt; target，移动较大的元素，使 sum 变小一些； 如果 sum &lt; target，移动较小的元素，使 sum 变大一些。 12345678910111213141516class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int i = 0, j = numbers.length - 1; while (i &lt; j) &#123; int sum = numbers[i] + numbers[j]; if (sum == target) &#123; return new int[]&#123;i + 1, j + 1&#125;; &#125; else if (sum &lt; target) &#123; i++; &#125; else &#123; j--; &#125; &#125; return null; &#125;&#125; 复杂度分析 时间复杂度：O(N)。双指针，从数组的两边开始，只遍历一次。 空间复杂度：O(1)。在原地操作没有使用额外空间。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-88-合并两个有序数组]]></title>
    <url>%2F2018%2F10%2F22%2FLeetCode-088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[合并两个有序数组LeetCode-cn-88-合并两个有序数组 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 解决方案方法一：双指针 因为nums1 有足够的空间，可以先划定nums1最后完成时，末尾下标，记为 size。同时使用双指针，一个指向nums1， 一个指向nums2，比较，将大的一个数，放在size–的位置上。 1234567891011121314151617class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int len1 = m - 1, len2 = n -1; int size = m + n -1; while(len1 &gt;= 0 || len2 &gt;= 0)&#123; if(len1 &lt; 0)&#123; nums1[size--] = nums2[len2--]; &#125;else if(len2 &lt; 0)&#123; nums1[size--] = nums1[len1--]; &#125;else if(nums1[len1] &gt; nums2[len2])&#123; nums1[size--] = nums1[len1--]; &#125;else &#123; nums1[size--] = nums2[len2--]; &#125; &#125; &#125;&#125; 复杂度分析 时间复杂度：O(n+m)，只遍历了一遍数组/ 空间复杂度：O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-26-删除数组中的重复项]]></title>
    <url>%2F2018%2F10%2F22%2FLeetCode-026-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[删除数组中的重复项LeetCode-cn-26-删除数组中的重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 为什么返回数值是整数，但输出的答案是数组呢? 请注意输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 解决方案方法一： 双指针算法 数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。当我们遇到 nums[j] != nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它nums[j]的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 达数组的末尾为止。 1234567891011public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; 复杂度分析 时间复杂度：15ms, O(n)， 假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。 空间复杂度：O(1)。 方法二：我的做法 双指针 一快一慢两个指针。 public static intremoveDuplicates(it[] nums) { if(nums.length== 0) return 0; int i = 0, j =1; while(j &lt;=nums.length -1) { if(nums[i]== nums[j]){ j++; }elseif(nums[i] &lt;nums[j]){ swap(nums,++i, j++); } } return i+1; } private static voidswap(int[] nums,int i, int j) { int tmp =nums[i]; nums[i] =nums[j]; nums[j] = tmp; } 复杂度分析 时间复杂度：9ms, O(n)， 假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。 空间复杂度：O(1)。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-14-最长公共前缀]]></title>
    <url>%2F2018%2F10%2F22%2FLeetCode-014-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[最长公共前缀LeetCode-cn-14-最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [“flower”,”flow”,”flight”] 输出: “fl” 示例 2: 输入: [“dog”,”racecar”,”car”] 输出: “” 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解决方案方法一：横向比较（自创） 数组大小若小于2 ，则直接返回第一个字符串。否则，首先拿出strs[0], strs[1], 进行比较，找出这两个最长的公共子串，记录在res中，之后，以同样的逻辑，在res和后边其他的数据进行比较。找出所有的公共字串。 12345678910111213141516171819202122232425262728class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if(strs == null || strs.length == 0) return ""; if(strs.length == 1) return strs[0]; String res = longestCommonPrefixHelp(strs[0], strs[1]); for(int i = 2; i &lt;= strs.length - 1; i++)&#123; res = longestCommonPrefixHelp(res, strs[i]); &#125; return res; &#125; public String longestCommonPrefixHelp(String s1, String s2)&#123; StringBuffer res = new StringBuffer(); int len = s1.length() &lt; s2.length() ? s1.length() : s2.length(); int i = 0; while(i &lt; len)&#123; if(s1.charAt(i) == s2.charAt(i))&#123; res.append(s1.charAt(i)); i++; &#125;else&#123; break; &#125; &#125; return res.toString(); &#125;&#125; 复杂度分析 时间复杂度：O(S)， S是字符串数组的所有字符的和。 空间复杂度：O(1)， 仅仅使用常量级别的额外空间。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-13-罗马数字转整数]]></title>
    <url>%2F2018%2F10%2F22%2FLeetCode-013-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[罗马数字转整数LeetCode-cn-13-罗马数字转整数 将罗马数字转换成整数输出罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如:罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: “III” 输出: 3 示例 2: 输入: “IV” 输出: 4 示例 3: 输入: “IX” 输出: 9 示例 4: 输入: “LVIII” 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: “MCMXCIV” 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 解决方案 将罗马字母和对应的int值存入hash表，遍历所给的字符串，if–else判断即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int romanToInt(String s) &#123; if(s == null || s.length() == 0) return 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int res = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) != 'I' &amp;&amp; s.charAt(i) != 'X' &amp;&amp; s.charAt(i) != 'C') &#123; res += map.get(s.charAt(i)); &#125; else &#123; if (s.charAt(i) == 'I') &#123;// 可能匹配 'IV' 'IX' if (i + 1 &lt; s.length() &amp;&amp; s.charAt(i + 1) == 'V') &#123; res += 4; i += 1; &#125; else if (i + 1 &lt; s.length() &amp;&amp; s.charAt(i + 1) == 'X') &#123; res += 9; i += 1; &#125; else &#123;// 未匹配到上边的选项，简单相加 res += map.get(s.charAt(i)); &#125; &#125; else if (s.charAt(i) == 'X') &#123;// 可能匹配 'XL' 'XC' if (i + 1 &lt; s.length() &amp;&amp; s.charAt(i + 1) == 'L') &#123; res += 40; i += 1; &#125; else if (i + 1 &lt; s.length() &amp;&amp; s.charAt(i + 1) == 'C') &#123; res += 90; i += 1; &#125; else &#123;// 未匹配到上边的选项，简单相加 res += map.get(s.charAt(i)); &#125; &#125; else if (s.charAt(i) == 'C') &#123;// 可能匹配 'CD' 'CM' if (i + 1 &lt; s.length() &amp;&amp; s.charAt(i + 1) == 'D') &#123; res += 400; i += 1; &#125; else if (i + 1 &lt; s.length() &amp;&amp; s.charAt(i + 1) == 'M') &#123; res += 900; i += 1; &#125; else &#123;// 未匹配到上边的选项，简单相加 res += map.get(s.charAt(i)); &#125; &#125; &#125; &#125; return res; &#125;&#125; 复杂度分析 时间复杂度： O(N)，只进行一次遍历，进行if–else 判断即可。 空间复杂度：O(7)，需要一个罗马字母和int值 的映射表]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-09-回文数]]></title>
    <url>%2F2018%2F10%2F22%2FLeetCode-009-%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[回文数LeetCode-cn-09-回文数 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 解决方案###方法一：反转一半数字 思路 映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。 第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。 但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。 按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。 例如: &lt;p style=”text-indent: 2em”输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 1221 是回文。 让我们看看如何将这个想法转化为一个算法。 算法 首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。 现在，让我们来考虑如何反转后半部分的数字。 对于数字 1221，如果执行 1221 % 10，我们将 得到最后一位数字 1 ，要 得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以10的余数，122 % 10 = 2，就可以得到倒数第二位数字。 如果我们 把最后一位数字乘以10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。 如果继续这个过程，我们将得到更多位数的反转数字。 现在的问题是，我们 如何知道反转数字的位数已经达到原始数字位数的一半？ 我们将原始数字除以 10，然后给反转后的数字乘上 10，所以， 当原始数字小于反转后的数字时 ，就意味着我们已经处理了一半位数的数字。 123456789101112131415161718192021222324//C++解决public class Solution &#123; public bool IsPalindrome(int x) &#123; // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; return false; &#125; int revertedNumber = 0; while(x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber/10; &#125;&#125; 复杂度分析 时间复杂度：O(log10(n))，对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(log10(n))。 空间复杂度：O(1)。 方法二：123456789101112131415161718//我的解决方案，时间339ms，javaclass Solution &#123; public boolean isPalindrome(int x) &#123; if(x &lt; 0) return false; String string = Integer.toString(x); int l = 0; int r = string.length() - 1; while(l &lt; r)&#123; if(string.charAt(l) != string.charAt(r)) return false; l++; r--; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-07-反转整数]]></title>
    <url>%2F2018%2F10%2F21%2FLeetCode-007-%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[反转整数LeetCode-cn-07-反转整数 给定一个32位有符号整数，将整数中的数字进行反转。 示例1： 输入：123 输出：321 示例2： 输入：-123 输出：-321 示例3： 输入：120 输出：21 注意：假设我们的环境只能存储32位有符号整数，其数值范围是[-2^31 , 2^31 - 1]。根据这个假设，如果反转后的整数溢出，则返回0. 解决方案：方法：弹出和推入数字 &amp; 溢出前进行检查思路: 我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。 算法 反转整数的方法可以与反转字符串进行类比。我们想重复“弹出”x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。 要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。 1234567//pop operation:pop = x % 10;x /= 10;//push operation:temp = rev * 10 + pop;rev = temp; 但是，这种方法很危险，因为当 最后一高位进行push 操作时，可能会造成溢出。因此，要在最后一次push前进行范围检查。 1234567891011121314public static int reverse(int x) &#123; double r = 0; while (true) &#123; int f = x % 10; x /= 10; if(x==0)&#123; if (r*10+f &gt; Integer.MAX_VALUE || r*10+f &lt; Integer.MIN_VALUE) return 0; else return (int)r*10+f; &#125; r = r * 10 + f; &#125;&#125; 复杂度分析 时间复杂度：O(log(x))，x 中大约有 log10(x) 位数字。 空间复杂度：O(1)。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-06-Z字形变换]]></title>
    <url>%2F2018%2F10%2F21%2FLeetCode-006-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Z字形变换LeetCode-cn-06-Z字形变换 将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：123P A H N A P L S I I GY I R 之后从左往右，逐行读取字符 “PAHNAPLSIIGYIR”实现一个将字符串进行指定行数变换的函数： ++string convert(string s, int numRows);++ 示例1： 输入: s = “PAYPALISHIRING”, numRows = 3 输出: “PAHNAPLSIIGYIR” 示例 2: 输入: s = “PAYPALISHIRING”, numRows = 4 输出: “PINALSIGYAHRPI” 解释: 1234P I NA L S I GY A H RP I 解决方案方法一： 按行排序思路 通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。 算法 我们可以使用 min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。 从左到右迭代 s，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。 只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。 1234567891011121314151617181920212223class Solution &#123; public String convert(String s, int numRows) &#123; if (numRows == 1) return s; List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; Math.min(numRows, s.length()); i++) rows.add(new StringBuilder()); int curRow = 0; boolean goingDown = false; for (char c : s.toCharArray()) &#123; rows.get(curRow).append(c); if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown; curRow += goingDown ? 1 : -1; &#125; StringBuilder ret = new StringBuilder(); for (StringBuilder row : rows) ret.append(row); return ret.toString(); &#125;&#125; 复杂度分析 时间复杂度：O(n)，其中 n == len(s) 空间复杂度：O(n) 方法二：按行访问思路 按照与逐行读取 Z 字形图案相同的顺序访问字符串。 算法 首先访问 行 0 中的所有字符，接着访问 行 1，然后 行 2，依此类推… 对于所有整数 k， 行 0 中的字符位于索引 k(2⋅numRows−2) 处; 行 numRows − 1 中的字符位于索引 k(2⋅numRows − 2) + numRows − 1 处; 内部的 行 ii 中的字符位于索引 k(2⋅numRows − 2) + i 以及(k+1)(2⋅numRows − 2) − i 处; 12345678910111213141516171819202122232425262728class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows == 1 || s == null || s.length() &lt; numRows) return s; String res = ""; int n1 = 2*numRows - 2, n2 = 0; for (int i = 0; i &lt; numRows; i++) &#123; int j = i;//字符的下标 res += s.charAt(j); boolean st1 = true,st2 = true; while(st1 || st2)&#123; if(n1 &gt; 0 &amp;&amp; (j += n1)&lt; s.length())&#123; res += s.charAt(j); &#125;else&#123; st1 = false; &#125; if(n2 &gt; 0 &amp;&amp; (j += n2)&lt; s.length())&#123; res += s.charAt(j); &#125;else&#123; st2 = false; &#125; &#125; n1 -= 2; n2 += 2; &#125; return res; &#125;&#125; 复杂度分析 时间复杂度：O(n)，其中 n == len(s)。每个索引被访问一次。 空间复杂度：O(n)。对于 cpp 实现，如果返回字符串不被视为额外空间，则复杂度为 O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-05-最长回文子串]]></title>
    <url>%2F2018%2F10%2F21%2FLeetCode-005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[最长回文子串LeetCode-cn-05-最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例 1： 输入: “babad” 输出: “bab” 注意: “aba”也是一个有效答案。 示例 2： 输入: “cbbd” 输出: “bb” 解决方案：方法一：动态规划 我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑“ababa” 这个示例。如果我们已经知道“bab”是回文，那么，“ababa”一定是回文，因为他的左首字母和右尾字母是相同的。 我们给出P(i, j) 的定义如下：P(i, j)={true, 如果子串Si, ….Sj是回文子串} {false， 其他情况} 因此， P(i , j) = (P(i + 1, j - 1) and Si == Sj) 基本示例例如下： P(i , j) = trueP(i , i+1) = (Si == Si+1) 这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并以此类推… 复杂度分析 时间复杂度：O(n^2)，这里给出我们的运行时间复杂度为O(n^2). 空间复杂度：O(n^2)，该方法使用O(n^2)的空间存储表。 方法二：中心扩展算法 事实上，只需使用恒定的时间，我们就可以在O(n^2)的时间内解决这个问题。 我们观察到回文中心的两侧互为镜像。因此，回文可以从他的中心展开，并且只有2n-1 个这样的中心. 你可能会问，为什么是2n-1个，而不是n个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间(例如“abba”的中心在两个b之间)。 12345678910111213141516171819202122class Solution &#123; private int index, len; public String longestPalindrome(String s) &#123; if(s.length() &lt; 2) return s; for(int i = 0; i &lt; s.length() - 1; i++)&#123; palindromHelp(s , i, i); palindromHelp(s , i, i+1); &#125; return s.substring(index, index + len); &#125; public void palindromHelp(String s, int l, int r)&#123; while(l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r))&#123; l--; r++; &#125; if(len&lt;r-l-1)&#123; index = l + 1; len = r - l - 1; &#125; &#125;&#125; 复杂度分析 时间复杂度：O(n^2)，由于围绕中心来扩展回文会好去O(n)的时间，所以总的复杂度为O(n^2) 空间复杂度：O(1)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-04-两个排序数组的中位数]]></title>
    <url>%2F2018%2F10%2F21%2FLeetCode-004-%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[两个排序数组的中位数LeetCode-cn-04-两个排序数组的中位数 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。你可以假设 nums1 和 nums2 不同时为空。 示例 1: nums1 = [1, 3] nums2 = [2] 中位数是 2.0 示例 2: nums1 = [1, 2] nums2 = [3, 4] 中位数是 (2 + 3)/2 = 2.5 解决方案：方法一： 利用归并排序的merge、部分 因为给定的两个排好序的数组，很容易想到归并排序的merge阶段。将两个排好序的数组合并，恰好只需要 O(m+n) 复杂度。 1234567891011121314151617public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int[] help = new int[nums1.length +nums2.length]; int i = 0; int l1 = 0 , l2 = 0; while (l1 &lt;= nums1.length - 1 &amp;&amp; l2 &lt;=nums2.length - 1) &#123; help[i++] = nums1[l1] &lt; nums2[l2]? nums1[l1++] : nums2[l2++]; &#125; while (l1 &lt;= nums1.length - 1) &#123; help[i++] = nums1[l1++]; &#125; while (l2 &lt;= nums2.length - 1) &#123; help[i++] = nums2[l2++]; &#125; if(help.length % 2 == 0) return (help[help.length/2] +help[help.length/2 - 1] + 0.0)/2; return help[help.length/2];&#125; 复杂度分析: 时间复杂度：O(n)，将两个排序的数组合并O(m+n)，找到中位数只需要O(1)的时间 空间复杂度：o(m+n),需要一个m+n大小的辅助数组，具体要看给定的nums1和nums2的大小 方法二： 递归法 为了解决这个问题，我们需要理解“中位数的作用是什么”。在统计中，中位数被用来： 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。 如果理解了中位数的划分作用，我们就很接近答案了。首先，让我们在任一位置 i 将 A 分成两个部分： left_A | right_A A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] 由于 A 中有 m 个元素， 所以我们有 m+1 种划分的方法（i = 0 ∼ m）。 我们知道： 1len(left_A) = i, len(right_A) = m - i 注意： 当 i=0 时，left_A 为空集， 而当 i = m时,right_A 为空集。采用同样的方式，我们在任一位置 jj 将 \text{B}B 划分成两个部分： left_B | right_B B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 将 left_A 和 left_B 放入一个集合，并将right_A 和 right_B 放入另一个集合。再把这两个新的集合分别命名为 left_part 和 right_part： left_part | right_part A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 如果我们可以确认： 1231. len(left\_part) = len(right\_part)2. max(left\_part) = min(right\_part) 那么，我们已经将 {A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么：1median= \frac&#123;max(left\_part)+min(right\_part)&#125;&#123;2&#125; 要确保这两个条件，我们只需要保证： i + j = m - i + n - j（或：m - i + n - j + 1） 如果 n ≥ m，只需要使 i = 0 ~ m, 1j = \frac&#123;m + n + 1&#125;&#123;2&#125; - i B[j - 1] &lt;= A[i] 以及 A[i - 1] &lt; B[j] ps.1 为了简化分析，我假设 A[i-1], B[j-1], A[i], B[j] 总是存在，哪怕出现 i=0，i=m，j=0，或是 j=n 这样的临界条件。 我将在最后讨论如何处理这些临界值。 ps.2 为什么n ≥ m？由于0 ≤ i ≤ m 且12345678910j = \frac&#123;m + n + 1&#125;&#123;2&#125; - i``` 我必须确保 j 不是负数。如果 n &lt; m，那么 j 将可能是负数，而这会造成错误的答案。所以，我们需要做的是：在 [0，m] 中搜索并找到目标对象 i，以使：&gt; B[j−1] ≤ A[i] 且 A[i−1] ≤ B[j], 其中 ```mathj = \frac&#123;m + n + 1&#125;&#123;2&#125; 接着，我们可以按照以下步骤来进行二叉树搜索：详情看这里 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public double findMedianSortedArrays(int[] A, int[] B) &#123; int m = A.length; int n = B.length; if (m &gt; n) &#123; // to ensure m&lt;=n int[] temp = A; A = B; B = temp; int tmp = m; m = n; n = tmp; &#125; int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) &#123; int i = (iMin + iMax) / 2; int j = halfLen - i; if (i &lt; iMax &amp;&amp; B[j-1] &gt; A[i])&#123; iMin = i + 1; // i is too small &#125; else if (i &gt; iMin &amp;&amp; A[i-1] &gt; B[j]) &#123; iMax = i - 1; // i is too big &#125; else &#123; // i is perfect int maxLeft = 0; if (i == 0) &#123; maxLeft = B[j-1]; &#125; else if (j == 0) &#123; maxLeft = A[i-1]; &#125; else &#123; maxLeft = Math.max(A[i-1], B[j-1]); &#125; if ( (m + n) % 2 == 1 ) &#123; return maxLeft; &#125; int minRight = 0; if (i == m) &#123; minRight = B[j]; &#125; else if (j == n) &#123; minRight = A[i]; &#125; else &#123; minRight = Math.min(B[j], A[i]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0; &#125;&#125; 复杂度分析： 时间复杂度：O(log(min(m,n)))，首先，查找的区间是 [0, m]。而该区间的长度在每次循环之后都会减少为原来的一半。 所以，我们只需要执行 log(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为O(log(m))。由于，m ≤ n 所以时间复杂度是 O(log(min(m,n)))。 空间复杂度：O(1)，我们只需要恒定的内存来存储 9 个局部变量， 所以空间复杂度为 O(1)。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-03-无重复字符的最长子串]]></title>
    <url>%2F2018%2F10%2F20%2FLeetCode-003-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[无重复字符的最长子串LeetCode-cn-03-无重复字符的最长子串 给定一个字符串，找出不含有重复字符的最长子串的长度。 示例 1: 输入: “abcabcbb” 输出: 3 解释: 无重复字符的最长子串是 “abc”，其长度为3。 示例 2: 输入: “bbbbb” 输出: 1 解释: 无重复字符的最长子串是 “b”，其长度为 1。 示例 3: 输入: “pwwkew” 输出: 3 解释: 无重复字符的最长子串是 “wke”，其长度为 3。 请注意: 答案必须是一个子串，”pwke” 是一个子序列 而不是子串。 解决方案：方法一：滑动窗口 如果从索引 i 到 j-1 之间的子字符串 s_{ij}已经被检查为没有重复字符。我们只需要检查s[j] 对应的字符是否已经存在于子字符串 s_{ij}中。 要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为 O(n^2)的算法，但我们可以做得更好。 通过使用 HashSet 作为 滑动窗口 ，我们可以用 O(1)的时间来完成对字符是否在当前的子字符串中的检查。滑动窗口 是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i,j)（左闭，右开） 。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。 例如，我们将[i,j)向右滑动1个元素，则它将变为 [i+1,j+1)（左闭，右开）。 回到我们的问题，我们使用HashSet将字符存储在当前窗口 [i, j)（最初 j = ij=i）中。然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。 此时，我们找到的没有重复字符的最长子字符串将会以索引 ii 开头。如果我们对所有的 ii 这样做，就可以得到答案。 123456789101112131415161718public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; // try to extend the range [i, j] if (!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125; 复杂度分析: 时间复杂度：O(2n)=O(n)，在最糟糕的情况下，每个字符将被 i 和 j 访问两次。 空间复杂度：O(min(m,n))，与之前的方法相同。滑动窗口法需要 O(k) 的空间，其中 k 表示 Set 的大小。而Set的大小取决于字符串n的大小以及字符集/字母 m 的大小。 方法二： 优化的滑动窗口 上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。 也就是说，如果 s[j] 在 [i,j) 范围内有与 j’ 重复的字符，我们不需要逐渐增加 i 。我们可以直接跳过 [i，j’]范围内的所有元素，并将 i 变为 j’ + 1。 Java（使用 HashMap） 1234567891011121314class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int l = 0; for (int j = 0, i = 0; j &lt; s.length(); j++) &#123; if(map.containsKey(s.charAt(j)))&#123; i = Math.max(map.get(s.charAt(j)), i);//两重复字符间最大 &#125; l = Math.max(j-i+1,l);//记录滑块最大的 map.put(s.charAt(j), j+1); &#125; return l; &#125;&#125; 方法三： 优化的滑动窗口2划重点Java（假设字符集为 ASCII 128） 以前的我们都没有对字符串 s 所使用的字符集进行假设。 当我们知道该字符集比较小的时侯，我们可以用一个整数数组作为直接访问表来替换 Map。 常用的表如下所示： int [26] 用于字母 ‘a’ - ‘z’或 ‘A’ - ‘Z’ int [128] 用于ASCII码 int [256] 用于扩展ASCII码 12345678910111213public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; &#125; return ans; &#125;&#125; 复杂度分析: 时间复杂度：O(n)，索引 j 将会迭代 n 次。 空间复杂度（HashMap）：O(min(m,n))，与之前的方法相同。 空间复杂度（Table）：O(m)，m是字符集的大小。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-02-两个链表相加]]></title>
    <url>%2F2018%2F10%2F20%2FLeetCode-002-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[两个链表相加LeetCode-cn-02-两个链表相加 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0之外，这两个数字都不会以零开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 解决方案：算法： 就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。由于每位数字都应当处于0···9的范围内，我们计算两个数字的和时可能会出现“溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为 2，并将进位 carry = 1带入下一次迭代。进位 carry 必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19。 伪代码如下： 将当前结点初始化为返回列表的哑结点。 将进位 carry 初始化为 0。 将 p 和 q 分别初始化为列表 l1 和 l2 的头部。 遍历列表 l1 和 l2 直至到达它们的尾端。 将 x 设为结点 p 的值。如果 p 已经到达 l1 的末尾，则将其值设置为 0。 将 y 设为结点 q 的值。如果 q 已经到达 l2 的末尾，则将其值设置为 0。 设定 sum = x + y + carry。 更新进位的值，carry = sum / 10。 创建一个数值为 (sum mod 10)的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。 同时，将 p 和 q 前进到下一个结点。 检查 carry = 1 是否成立，如果成立，则向返回列表追加一个含有数字 1 的新结点。 返回哑结点的下一个结点。 请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。 测试用例 说明 l1 = [0, 1] l2 =[0, 1, 2] 当一个列表比另一个列表长时 l1 = []l2 = [0, 1] 当一个列表为空时，即出现空列表 l1 = [9, 9]l2 = [1] 求和运算最后可能出现额外的进位，这一点很容易被遗忘 12345678910111213141516171819202122class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode res = new ListNode(0); ListNode p1 = l1, p2 = l2, cur = res; int carry = 0;//统计进位值 while(p1 != null || p2 != null)&#123; int x = (p1 != null) ? p1.val : 0;//如果p1节点为null, 则p1.val = 0 int y = (p2 != null) ? p2.val : 0;//如果p2节点为null, 则p2.val = 0 int sum = x + y + carry;//计算p1，p2和进位值，三个的和 carry = sum/10;//更新进位值 cur.next = new ListNode(sum%10) ;//将数据连入结果ListNode cur = cur.next; if(p1 != null)p1 = p1.next;//判断是不是为空，不是，就找他的下一个 if(p2 != null)p2 = p2.next; &#125; if(carry &gt; 0)&#123;//当两个链表加完之后，如果进位大于0，则还需要加上一个新的链表 cur.next = new ListNode(carry); &#125; return res.next;//因为结果res，是从第2个开始存储结果的，所以返回res.next&#125; 复杂度分析: 时间复杂度：O(max(m, n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max(m, n) 次。 空间复杂度：O(\max(m, n))O(max(m,n))， 新列表的长度最多为 \max(m,n) + 1max(m,n)+1。 拓展: 如果链表中的数字不是按逆序存储的呢？例如：(3 → 4 → 2) + (4 → 6 → 5) = 8 → 0 → 7]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-001_两数之和]]></title>
    <url>%2F2018%2F10%2F20%2FLeetCode-001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[两数之和LeetCode-cn-001-两数之和 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解决方案：方法一: 暴力法 暴力法很简单。遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素 123456789101112public int[] twoSum(int[] nums, int target)&#123; if(nums == null || nums.length &lt; 2) return null; for(int i = 0; i &lt; nums.length - 1;i++)&#123; for(int j = i + 1; j &lt; nums.length;j++)&#123; if(nums[i] + nums[j] ==target)&#123; return new int[]&#123;i,j&#125;; &#125; &#125; &#125; return null;&#125; 复杂度分析： 时间复杂度：O(n^2)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)。 空间复杂度：O(1)。 方法二：两遍哈希表 在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素(target -nums[i])是否存在于表中。注意，该目标元素不能是 nums[i]本身！ 12345678910111213141516class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length ; i ++)&#123; map.put(nums[i], i); &#125; for(int i = 0; i &lt; nums.length; i++)&#123; int compare = target - nums[i]; if(map.containsKey(compare) &amp;&amp; map.get(compare) != i)&#123; return new int[]&#123;i,map.get(compare)&#125;; &#125; &#125; throw new IllegalArgumentException("No two sum solution"); &#125;&#125; 复杂度分析： 时间复杂度：O(n)， 我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。 方法三：一遍哈希表 在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素对应的目标元素。如果存在，那我们已经找到了对迎接并立即将其返回。 1234567891011public int[] twoSum(int[] nums, int target)&#123; Map&lt;Integer, Integer&gt; map = newHashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; int compare = target - nums[i]; if(map.containsKey(compare) &amp;&amp;map.get(compare) != i)&#123; return newint[]&#123;map.get(compare), i&#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("Notwo sum solution");&#125; 复杂度分析: 时间复杂度：O(n)，我们之遍历了包含有n个元素的列表一次次。在表中进行的每次查找只花费O(1)的时间。 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储n个元素。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左神算法-04_小和问题和逆序对问题]]></title>
    <url>%2F2018%2F10%2F18%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-04_%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98%26%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左神算法-03-master公式&归并排序]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-03_master%E5%85%AC%E5%BC%8F%26%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[剖析递归行为和递归行为时间复杂度的估算以及归并排序 剖析递归行为和递归行为时间复杂度的估算一个递归行为的例子 master公式的使用 T(N) = a*T(N/b) + O(N^d) T(N)是样本量为N时的时间复杂度，N/b是划分成子问题的样本量，子问题发生了a次，后面O(N^d)是除去调用子过程之外的时间复杂度。 比如要求一个数组的最大值：1234567891011public static int getMax(int[] arr, int L, int R) &#123; if (L == R) &#123; return arr[L]; &#125; int mid = (L + R) &gt;&gt;&gt; 1; int maxLeft = getMax(arr, L, mid); int maxRight = getMax(arr, mid + 1, R); return Math.max(maxLeft, maxRight);&#125;//master公式： T(N) = 2*T(N/2) + O(1); 这里划分成的递归子过程的样本量是N/2，这个相同的样本量发生了2次，除去调用子过程之外的时间复杂度是O(1),因为求最大值和判断if复杂度是O(1),所以N^d=1，所以d=0. 那么根据如下公式判断 log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a)) log(b,a) = d -&gt; 复杂度为O(N^d * logN) log(b,a) &lt; d -&gt; 复杂度为O(N^d) 这里log(b, a)(以b为底a的对数) = log(2, 2)=1 &gt; d=0所以复杂度为O(N^log(2, 2))===&gt;O(N)，因此也就可以解释为什么归并排序的时间复杂度为nlogn了 归并排序 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。 12345678910111213141516171819202122232425262728293031323334public static void mergeSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; mergeSort(arr, 0, arr.length - 1);&#125;public static void mergeSort(int[] arr, int l, int r) &#123; if (l == r) &#123; return; &#125; int mid = l + ((r - l) &gt;&gt; 1); mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); merge(arr, l, mid, r);&#125;public static void merge(int[] arr, int l, int m, int r) &#123; int[] help = new int[r - l + 1]; int i = 0; int p1 = l; int p2 = m + 1; while (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123; help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] :arr[p2++]; &#125; while (p1 &lt;= m) &#123; help[i++] = arr[p1++]; &#125; while (p2 &lt;= r) &#123; help[i++] = arr[p2++]; &#125; for (i = 0; i &lt; help.length; i++) &#123; arr[l + i] = help[i]; &#125;&#125; 总结： 归并排序是稳定排序，他也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左神算法-02_简单排序]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-02_%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。我们这里说说八大排序的内部排序。 概述 排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。我们这里说说八大排序的内部排序。 当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短； 冒泡排序 冒泡排序的核心是从头遍历序列。以升序排列为例：将第一个元素和第二个元素比较，若前者大于后者，则交换两者的位置，再将第二个元素与第三个元素比较，若前者大于后者则交换两者位置，以此类推直到倒数第二个元素与最后一个元素比较，若前者大于后者，则交换两者位置。这样一轮比较下来将会把序列中最大的元素移至序列末尾，这样就安排好了最大数的位置(每次找到一个最大的)，接下来只需对剩下的（n-1）个元素，重复上述操作即可. 123456789101112131415161718//时间复杂度O(N^2)， 额外空间复杂度O(1)public class Coding_00_bubbleSort &#123; public static void bubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = arr.length - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) swap(arr, j, j + 1); &#125; &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125;&#125; 插入排序 插入即表示将一个新的数据插入到一个有序数组中，并继续保持有序。例如有一个长度为N的无序数组，进行N-1次的插入即能完成排序；第一次，数组第1个数认为是有序的数组，将数组第二个元素插入仅有1个有序的数组中；第二次，数组前两个元素组成有序的数组，将数组第三个元素插入由两个元素构成的有序数组中……第N-1次，数组前N-1个元素组成有序的数组，将数组的第N个元素插入由N-1个元素构成的有序数组中，则完成了整个插入排序。 类似手里有一把排好序的牌，心哪一张和最后一个比较，看能插到前边哪个位置上。 12345678910111213141516171819//时间复杂度O(N^2)， 额外空间复杂度O(1)//实际时间和数据有关系O(N)~O(N^2)// 排好序的数据~逆序数据public class Coding_01_insertSort &#123; public static void insertSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123; swap(arr, j, j + 1); &#125; &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125;&#125; 选择排序 选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 注意: 选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置12345678910111213141516171819//时间复杂度O(N^2)， 额外空间复杂度O(1)public class Coding_02_selectSort &#123; public static void selectSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; for(int j = i + 1; j &lt; arr.length; j++)&#123; minIndex = arr[j] &lt; arr[minIndex] ? j: minIndex; &#125; swap(arr, i, minIndex); &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左神算法-01_时间复杂度]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95-01_%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关。 时间复杂度 时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为O(n)），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于常数时间内的操作（对应时间复杂度O(1)）。 常数时间操作： 一个操作如果和数据量没有关系，每次都子啊固定时间内完成的操作，叫做常数操作。 在化简某算法时间复杂度表达式时需遵循以下规则： 对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如O(n^2)+O(n)可化简为O(n^2)，O(n)+O(1)可化简为O(n) 可省去样本量前的常量系数，如O(2n)可化简为O(n)，O(8)可化简为O(1) 对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如O(logm)+O(n^2)不能化简为O(n^2)或O(logm)。而要视m、n两者之间的差距来化简，比如m&gt;&gt;n时可以化简为O(logm)，因为表达式增量是由样本量决定的。 举个例子例1. 对一个长度为N的数组进行排序： 算法：依次从0—-N-1个数中选出最小的数，放在数组的0位置从1—N-2个数中选出最小的数，放在数组的1位置从2—N-3个数中选出最小的数，放在数组的2位置time=N+(N-1)+(N-2)*+1=(N+1)N/2只要高阶项，不要低阶项，也不要高阶项的系数所以时间复杂度位O（NN） 例2. 一个有序数组A，另一个无序数组B，请打印B中所有不在A中的数，A数组的长度为N，B数组的长度为M。 算法1：对于数组B中的每一个数，都在A中通过遍历的方式找一下； 算法2：对于数组B中的每一个数，都在A中通过二分的方式查找一下； 算法3：先把B中的数进行排序，然后用类似外排的方式打印所有不在A中出现的数。计算时间复杂度： 1、O(M*N)2、 ①对有序的数组，二分查找的时间复杂度O（logN） 底数为2 在1,3,5,6,8,10中找出x L………………R mid=(L+R)/2 ，根据,数组[mid]与x比较大小的结果，确定下一次二分的方向，N个数二分最多能分logN次。 ②所以算法2的时间复杂度为 O（MlogN）3、 ①对无序数组使用基于比较的排序算法O(MlogM) ②1,3,5,7,10,16,18;2,4,8,17,20 ….a…………………….b……]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，陌生人]]></title>
    <url>%2F2018%2F10%2F15%2F%E4%BD%A0%E5%A5%BD%E9%99%8C%E7%94%9F%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[#post-js{width:980px;height:630px;color:#0099ff;margin:auto;font-size:25px;font-family:”华文行楷”;} 你好, 陌生人]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
